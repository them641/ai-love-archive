<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THEM 641 // New Audit</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --warm-red: rgba(200, 16, 46, 0.2);
            --cream: #fff5e6;
            --soft-blue: #b3d9ff;
            --paper: rgba(255, 245, 230, 0.95);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center,
                rgba(0, 0, 0, 0.9) 0%,
                rgba(0, 0, 0, 1) 100%
            );
            transition: background 3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            opacity: 0.3;
            mix-blend-mode: overlay;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: radial-gradient(circle at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 100%);
        }

        .fade-transition {
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .rothko-window {
            position: absolute;
            width: 25vw;
            height: 45vh;
            opacity: 0;
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(45deg, #8B0000, #FF4500);
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0,0,0,0.3);
            transform: scale(0.8) translateY(20px);
            filter: contrast(1.2) brightness(1.1);
            mix-blend-mode: screen;
            transform-origin: center;
        }

        .rothko-window.active {
            opacity: 1;
            transform: scale(1) translateY(0);
            animation: float 8s infinite ease-in-out;
        }

        .face {
            position: absolute;
            width: 3vmin;
            height: 3vmin;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transform: scale(0) rotate(-180deg);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
            mix-blend-mode: screen;
            filter: blur(1px);
        }

        .face.active {
            opacity: 0.7;
            transform: scale(1) rotate(0deg);
            animation: pulse 2s infinite ease-in-out;
        }

        .number {
            position: absolute;
            color: #ffcccc;
            font-size: calc(1vw + 0.5vh);
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 0 5px rgba(255,204,204,0.5);
            mix-blend-mode: overlay;
            filter: blur(0.5px);
            text-shadow: 0 0 8px currentColor;
        }

        .number.active {
            opacity: 0.8;
            transform: scale(1);
            animation: float 4s infinite ease-in-out;
        }

        .connection-line {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,51,51,0), rgba(255,51,51,1), rgba(255,51,51,0));
            height: 1px;
            transform-origin: left center;
            opacity: 0;
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 8px rgba(255,51,51,0.5);
            mix-blend-mode: screen;
            filter: blur(1px);
        }

        .heart {
            position: absolute;
            width: calc(1vw + 1vh);
            height: calc(1vw + 1vh);
            background: #ff6666;
            transform: rotate(45deg) scale(0);
            opacity: 0;
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 0 5px rgba(255,102,102,0.5));
            mix-blend-mode: screen;
            filter: blur(1px) contrast(1.2);
        }

        .heart.active {
            opacity: 0.9;
            transform: rotate(45deg) scale(1);
            animation: float 3s infinite ease-in-out;
        }

        .shape {
            position: absolute;
            background: radial-gradient(circle at center, #ff0000 0%, transparent 70%);
            opacity: 0;
            width: 100vw;
            height: 100vh;
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            mix-blend-mode: screen;
            filter: contrast(1.3);
        }

        .spiral {
            width: calc(2vw + 2vh);
            height: calc(2vw + 2vh);
            border: 2px solid #ff8080;
            border-radius: 50%;
            position: absolute;
            opacity: 0;
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(255,128,128,0.3);
            backdrop-filter: blur(2px);
            mix-blend-mode: screen;
            filter: blur(2px);
            backdrop-filter: blur(4px);
        }

        .watching-eye {
            width: calc(5vw + 5vh);
            height: calc(5vw + 5vh);
            border: 4px solid #fff;
            border-radius: 50%;
            position: absolute;
            opacity: 0;
            transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
            backdrop-filter: blur(3px);
            mix-blend-mode: screen;
            filter: contrast(1.2) brightness(1.2);
            backdrop-filter: blur(5px);
        }

        .pupil {
            width: calc(1.5vw + 1.5vh);
            height: calc(1.5vw + 1.5vh);
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .memory-pool {
            position: fixed;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(calc(2vw + 2vh), 1fr));
            gap: calc(0.5vw + 0.5vh);
            width: 95vw;
            height: 95vh;
            padding: calc(1vw + 1vh);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.08) 0%,
                rgba(255, 255, 255, 0.12) 50%,
                rgba(255, 255, 255, 0.08) 100%
            );
            border-radius: 2vmin;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                inset 0 0 32px 0 rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            z-index: 1;
        }

        .memory-pool.active {
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1);
        }

        .memory-pool::before {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            border-radius: 2vmin;
            background: radial-gradient(
                circle at 50% 50%,
                rgba(255, 255, 255, 0.15) 0%,
                rgba(255, 255, 255, 0.08) 50%,
                transparent 100%
            );
            z-index: -1;
            pointer-events: none;
            filter: blur(10px);
        }

        .memory-fragment {
            width: 100%;
            aspect-ratio: 1;
            background: radial-gradient(
                circle at center,
                rgba(255, 192, 203, 0.4),
                rgba(255, 192, 203, 0.1) 50%,
                transparent 80%
            );
            border-radius: 50%;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform: scale(0.9);
            position: relative;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .memory-fragment::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 60%;
            height: 60%;
            background: radial-gradient(
                circle at center,
                rgba(255, 255, 255, 0.3),
                transparent 70%
            );
            border-radius: 50%;
            filter: blur(2px);
        }

        .memory-fragment:hover {
            transform: scale(1.1);
            background: radial-gradient(
                circle at center,
                rgba(255, 192, 203, 0.6),
                rgba(255, 192, 203, 0.2) 50%,
                transparent 80%
            );
            animation: glow 2s infinite ease-in-out;
            box-shadow: 
                0 0 20px rgba(255, 192, 203, 0.3),
                inset 0 0 15px rgba(255, 255, 255, 0.2);
        }

        @keyframes glow {
            0%, 100% { 
                filter: brightness(1) blur(2px); 
                transform: scale(1.1);
            }
            50% { 
                filter: brightness(1.3) blur(3px); 
                transform: scale(1.15);
            }
        }

        .title {
            font-family: monospace;
            font-size: calc(5vw + 5vh);
            font-weight: bold;
            color: #fff;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            text-shadow: 
                0 0 20px rgba(255,255,255,0.9),
                0 0 40px rgba(255,255,255,0.6),
                0 0 60px rgba(255,255,255,0.4);
            letter-spacing: 0.2em;
            opacity: 0;
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 3;
            mix-blend-mode: screen;
        }

        .title.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            filter: brightness(1.5) contrast(1.2);
        }

        .final-layer {
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255,220,200,0.3) 0%, rgba(255,180,160,0.1) 20%, transparent 40%) 0 0,
                radial-gradient(circle at 50% 50%, rgba(255,200,180,0.2) 0%, rgba(255,160,140,0.08) 15%, transparent 35%) 30px 30px,
                radial-gradient(circle at 50% 50%, rgba(255,240,220,0.25) 0%, rgba(255,200,180,0.1) 25%, transparent 45%) 60px 60px;
            background-size: 120px 120px;
            background-color: rgba(0, 0, 0, 0.92);
            pointer-events: none;
            mix-blend-mode: screen;
            z-index: 2;
            opacity: 0;
            transition: opacity 2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .final-layer.active {
            opacity: 1;
            animation: dotLife 8s infinite linear;
        }

        /* Only hide memory pool and canvas */
        .final-layer.active ~ .memory-pool,
        .final-layer.active ~ canvas {
            opacity: 0 !important;
            transition: opacity 1s ease-out;
        }

        @keyframes dotLife {
            0%, 100% {
                background-position: 0 0, 30px 30px, 60px 60px;
                filter: brightness(1) contrast(1);
            }
            25% {
                background-position: 30px 0, 60px 30px, 0 60px;
                filter: brightness(1.1) contrast(1.05);
            }
            50% {
                background-position: 60px 0, 0 30px, 30px 60px;
                filter: brightness(0.95) contrast(1.1);
            }
            75% {
                background-position: 30px 0, -30px 30px, 60px 60px;
                filter: brightness(1.05) contrast(0.95);
            }
        }

        .glitch {
            animation: glitch 0.1s infinite;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            opacity: 0;
            transition: opacity 2s ease;
            mix-blend-mode: screen;
            filter: contrast(1.2) brightness(1.1);
        }

        /* Saul Bass inspired intro elements */
        .intro-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 1.5s cubic-bezier(0.7, 0, 0.3, 1);
        }

        .intro-container.slide-out {
            transform: translateX(-100vw);
        }

        .intro-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .intro-element {
            position: absolute;
            background: #ff3333;
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
        }

        .intro-bar {
            height: 8vh;
            width: 0;
            background: #ff3333;
            transform-origin: left center;
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
        }

        .intro-circle {
            width: 20vmin;
            height: 20vmin;
            background: #000;
            border: 4px solid #ff3333;
            border-radius: 50%;
            transform: scale(0);
            opacity: 0;
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
        }

        .intro-text {
            font-family: "Helvetica Neue", Arial, sans-serif;
            font-size: 8vw;
            font-weight: bold;
            color: #fff;
            position: absolute;
            opacity: 0;
            transform: scale(0.8);
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        .intro-number {
            font-family: "Helvetica Neue", Arial, sans-serif;
            font-size: 20vw;
            font-weight: bold;
            color: #ff3333;
            position: absolute;
            opacity: 0;
            transform: scale(2);
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
        }

        /* Enhanced dramatic elements */
        .dramatic-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, 
                rgba(255, 51, 51, 0) 0%,
                rgba(255, 51, 51, 0.1) 50%,
                rgba(0, 0, 0, 0.5) 100%
            );
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s cubic-bezier(0.7, 0, 0.3, 1);
            mix-blend-mode: overlay;
            z-index: 5;
        }

        .dramatic-line {
            position: absolute;
            background: #ff3333;
            height: 2px;
            width: 0;
            opacity: 0;
            transform-origin: left center;
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
        }

        .dramatic-text {
            position: absolute;
            font-family: "Helvetica Neue", Arial, sans-serif;
            font-size: 3vw;
            color: #fff;
            opacity: 0;
            transform: translateY(20px);
            transition: all 1s cubic-bezier(0.7, 0, 0.3, 1);
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }

        /* Enhanced visual elements */
        .rothko-window {
            clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
        }

        .rothko-window.active {
            clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
        }

        .face {
            clip-path: circle(50% at 50% 50%);
        }

        .number {
            text-transform: uppercase;
            font-family: "Helvetica Neue", Arial, sans-serif;
            font-weight: bold;
        }

        .connection-line {
            transform-origin: left center;
            height: 2px;
        }

        .heart {
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        }

        /* Enhanced memory pool */
        .memory-fragment {
            clip-path: circle(40% at 50% 50%);
        }

        /* Start overlay styles */
        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .start-button {
            padding: 20px 40px;
            font-size: 24px;
            background: #ff3333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: "Helvetica Neue", Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            transition: all 0.3s ease;
        }

        .start-button:hover {
            background: #ff6666;
            transform: scale(1.05);
        }

        .frosted-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(1px);
            animation: dotFloat 3s infinite ease-in-out;
            pointer-events: none;
        }

        .pool-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            filter: blur(2px);
            pointer-events: none;
            animation: poolFloat 5s infinite ease-in-out;
        }

        @keyframes dotFloat {
            0%, 100% {
                transform: translate(0, 0) scale(1);
                opacity: 0.4;
            }
            50% {
                transform: translate(5px, -5px) scale(1.2);
                opacity: 0.6;
            }
        }

        @keyframes poolFloat {
            0%, 100% {
                transform: translate(0, 0) scale(1);
                opacity: 0.2;
            }
            50% {
                transform: translate(10px, -10px) scale(1.2);
                opacity: 0.4;
            }
        }
    </style>
</head>
<body>
    <div class="intro-container">
        <div class="intro-content">
            <div class="intro-bar"></div>
            <div class="intro-circle"></div>
            <div class="intro-text">THEM</div>
            <div class="intro-number">641</div>
        </div>
    </div>
    <div class="dramatic-overlay"></div>
    <div class="container">
        <div class="title">THEM 641</div>
        <canvas id="hypercube"></canvas>
        <div class="memory-pool"></div>
        <div class="dramatic-line"></div>
        <div class="dramatic-text">New Audit Sequence Initiated</div>
    </div>

    <script>
        const container = document.querySelector('.container');
        const title = document.querySelector('.title');
        const memoryPool = document.querySelector('.memory-pool');
        const canvas = document.querySelector('#hypercube');

        // Unified Audio System
        const audioSystem = {
            ctx: null,
            masterGain: null,
            isInitialized: false,
            currentDrone: null,
            chorusVoices: null,

            init() {
                if (this.isInitialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.masterGain.connect(this.ctx.destination);
                    this.isInitialized = true;
                    console.log("Audio system initialized");
                } catch (e) {
                    console.error("Audio initialization failed:", e);
                }
            },

            async start() {
                if (!this.isInitialized) this.init();
                try {
                    await this.ctx.resume();
                    this.startHarmony();
                    console.log("Audio started");
                } catch (e) {
                    console.error("Audio start failed:", e);
                }
            },

            createReverb() {
                const convolver = this.ctx.createConvolver();
                const rate = this.ctx.sampleRate;
                const length = rate * 4; // 4 seconds
                const decay = 2.5;
                const impulse = this.ctx.createBuffer(2, length, rate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const t = i / rate;
                        channelData[i] = (Math.random() * 2 - 1) * Math.exp(-t * decay);
                    }
                }
                
                convolver.buffer = impulse;
                return convolver;
            },

            createWarmFilter() {
                const lowpass = this.ctx.createBiquadFilter();
                lowpass.type = 'lowpass';
                lowpass.frequency.value = 2000;
                lowpass.Q.value = 0.5;

                const highpass = this.ctx.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 60;
                
                const lowShelf = this.ctx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 300;
                lowShelf.gain.value = 6; // Boost warm frequencies
                
                const highShelf = this.ctx.createBiquadFilter();
                highShelf.type = 'highshelf';
                highShelf.frequency.value = 3000;
                highShelf.gain.value = -6; // Reduce harsh frequencies
                
                // Chain filters
                lowpass.connect(highpass);
                highpass.connect(lowShelf);
                lowShelf.connect(highShelf);
                
                return {
                    input: lowpass,
                    output: highShelf
                };
            },

            createDrone(frequency, harmonics) {
                const oscillators = [];
                const gains = [];
                const filters = this.createWarmFilter();
                const reverb = this.createReverb();
                const dryGain = this.ctx.createGain();
                const wetGain = this.ctx.createGain();
                
                // Set wet/dry mix
                dryGain.gain.value = 0.4;
                wetGain.gain.value = 0.6;
                
                // Connect effects chain
                filters.output.connect(dryGain);
                filters.output.connect(reverb);
                reverb.connect(wetGain);
                dryGain.connect(this.masterGain);
                wetGain.connect(this.masterGain);
                
                harmonics.forEach((harmonic, i) => {
                    // Create richer oscillator mix
                    const oscCount = 3; // Multiple oscillators per harmonic
                    for (let j = 0; j < oscCount; j++) {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        
                        // Vary oscillator types for richness
                        osc.type = ['sine', 'triangle', 'sine'][j];
                        
                        // Slightly detune each oscillator for thickness
                        const detune = (Math.random() - 0.5) * 10;
                        osc.frequency.value = frequency * harmonic;
                        osc.detune.value = detune;
                        
                        // Reduce gain for multiple oscillators
                        gain.gain.value = 0;
                        
                        osc.connect(gain);
                        gain.connect(filters.input);
                        
                        oscillators.push(osc);
                        gains.push(gain);
                        
                        osc.start();
                    }
                });
                
                return { 
                    oscillators, 
                    gains,
                    filters,
                    reverb,
                    dryGain,
                    wetGain
                };
            },

            fadeDrone(gains, fadeIn, duration = 2) {
                const targetValue = fadeIn ? 0.05 / gains.length : 0; // Reduced gain for warmer sound
                gains.forEach(gain => {
                    gain.gain.setTargetAtTime(targetValue, this.ctx.currentTime, duration / 3);
                });
            },

            createChorus(frequency, spread = 2, rate = 0.1) {
                const voices = [];
                const filters = this.createWarmFilter();
                const reverb = this.createReverb();
                const dryGain = this.ctx.createGain();
                const wetGain = this.ctx.createGain();
                
                dryGain.gain.value = 0.4;
                wetGain.gain.value = 0.6;
                
                filters.output.connect(dryGain);
                filters.output.connect(reverb);
                reverb.connect(wetGain);
                dryGain.connect(this.masterGain);
                wetGain.connect(this.masterGain);
                
                for (let i = 0; i < 3; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    const detune = (i - 1) * spread;
                    osc.frequency.value = frequency;
                    osc.detune.value = detune;
                    
                    // Warmer modulation
                    const lfo = this.ctx.createOscillator();
                    const lfoGain = this.ctx.createGain();
                    lfo.frequency.value = rate + (i * 0.01);
                    lfoGain.gain.value = detune / 8;
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.detune);
                    
                    osc.connect(gain);
                    gain.connect(filters.input);
                    gain.gain.value = 0;
                    
                    osc.start();
                    lfo.start();
                    
                    voices.push({ 
                        osc, 
                        gain,
                        lfo,
                        lfoGain 
                    });
                }
                
                return {
                    voices,
                    filters,
                    reverb,
                    dryGain,
                    wetGain
                };
            },

            startHarmony() {
                const baseFreq = 220; // A3
                
                // Create richer harmonic series
                const warmHarmonics = [
                    1,      // fundamental
                    PHI,    // golden ratio
                    1.5,    // perfect fifth
                    2,      // octave
                    2.5,    // major third (next octave)
                    PHI * 2 // golden ratio (next octave)
                ].map(h => h % 3 + 1); // Keep in warmer register
                
                this.currentDrone = this.createDrone(baseFreq, warmHarmonics);
                this.chorusVoices = this.createChorus(baseFreq * 1.5); // Perfect fifth for warmth
                
                // Gradual fade-in
                setTimeout(() => {
                    this.fadeDrone(this.currentDrone.gains, true, 4); // Longer fade for smoothness
                    
                    // Slowly increase reverb wet mix
                    this.currentDrone.wetGain.gain.setTargetAtTime(0.7, this.ctx.currentTime, 3);
                    this.chorusVoices.wetGain.gain.setTargetAtTime(0.7, this.ctx.currentTime, 3);
                }, 0);
                
                const phases = [
                    { time: 6000, freq: baseFreq * PHI, wet: 0.75 },
                    { time: 12000, freq: baseFreq * 1.5, wet: 0.8 },
                    { time: 18000, freq: baseFreq * 2, wet: 0.85 },
                    { time: 24000, freq: baseFreq * 2.5, wet: 0.9 },
                    { time: 30000, freq: baseFreq * PHI * 2, wet: 0.95 },
                    { time: 34000, freq: baseFreq * 3, wet: 1.0 }
                ];
                
                phases.forEach(phase => {
                    setTimeout(() => {
                        // Smooth frequency transitions
                        this.currentDrone.oscillators.forEach((osc, i) => {
                            const targetFreq = phase.freq * warmHarmonics[i % warmHarmonics.length];
                            osc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 2);
                        });
                        
                        // Evolving chorus
                        this.chorusVoices.voices.forEach(voice => {
                            voice.gain.gain.setTargetAtTime(0.08, this.ctx.currentTime, 2);
                            voice.osc.frequency.setTargetAtTime(phase.freq * 1.5, this.ctx.currentTime, 2);
                        });
                        
                        // Increase wetness gradually
                        this.currentDrone.wetGain.gain.setTargetAtTime(phase.wet, this.ctx.currentTime, 3);
                        this.chorusVoices.wetGain.gain.setTargetAtTime(phase.wet, this.ctx.currentTime, 3);
                    }, phase.time);
                });
                
                // Gentle fade-out
                setTimeout(() => {
                    this.fadeDrone(this.currentDrone.gains, false, 5);
                    this.chorusVoices.voices.forEach(voice => {
                        voice.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 4);
                    });
                    
                    // Fade out reverb last
                    setTimeout(() => {
                        this.currentDrone.wetGain.gain.setTargetAtTime(0, this.ctx.currentTime, 3);
                        this.chorusVoices.wetGain.gain.setTargetAtTime(0, this.ctx.currentTime, 3);
                    }, 2000);
                }, 40000);
            }
        };

        // Initialize sequence with user interaction
        function initializeExperience() {
            const overlay = document.createElement('div');
            overlay.className = 'start-overlay';
            const button = document.createElement('button');
            button.className = 'start-button';
            button.textContent = 'Begin Experience';
            overlay.appendChild(button);
            document.body.appendChild(overlay);

            button.addEventListener('click', async () => {
                await audioSystem.start();
                overlay.remove();
                playIntroSequence();
            });
        }

        // Start with initialization
        initializeExperience();

        // Audio context setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playNote(frequency, time) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;
            
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + time);
        }

        function playTheremin(frequency, duration) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Enhanced animation functions
        function createRothkoWindows() {
            const colors = [
                ['#8B0000', '#FF4500'],
                ['#800080', '#FF1493'],
                ['#4B0082', '#9400D3']
            ];

            for (let i = 0; i < 3; i++) {
                const window = document.createElement('div');
                window.className = 'rothko-window';
                window.style.left = `${25 + i * 25}vw`;
                window.style.top = '25vh';
                window.style.background = `linear-gradient(45deg, ${colors[i][0]}, ${colors[i][1]})`;
                container.appendChild(window);

                setTimeout(() => {
                    window.classList.add('active');
                    playNote(220 + (i * 110), 1.0);
                }, i * 1500);

                setTimeout(() => {
                    window.style.transform = 'scale(0.8) translateY(-20vh)';
                    window.style.opacity = '0';
                    setTimeout(() => window.remove(), 2000);
                }, 7000 + i * 500);
            }
        }

        function createFaceGrid() {
            const gridSize = Math.floor(Math.min(window.innerWidth, window.innerHeight) / 50);
            const spacing = Math.min(window.innerWidth, window.innerHeight) / gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const face = document.createElement('div');
                    face.className = 'face';
                    face.style.left = `${window.innerWidth/2 - (gridSize * spacing)/2 + i * spacing}px`;
                    face.style.top = `${window.innerHeight/2 - (gridSize * spacing)/2 + j * spacing}px`;
                    container.appendChild(face);
                    
                    setTimeout(() => {
                        face.classList.add('active');
                    }, (i + j) * 100);
                    
                    setTimeout(() => {
                        face.classList.remove('active');
                        setTimeout(() => face.remove(), 1000);
                    }, 6000 + (i + j) * 100);
                }
            }
        }

        function createNumberGrid() {
            const total = 641;
            const duration = 5000; // Total duration for all numbers
            const staggerDelay = duration / total;

            for (let i = 1; i <= total; i++) {
                const number = document.createElement('div');
                number.className = 'number';
                number.textContent = i;
                
                // Calculate position using sine waves for more organic movement
                const angle = (i / total) * Math.PI * 2;
                const radius = Math.min(window.innerWidth, window.innerHeight) * 0.4;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                number.style.left = `${window.innerWidth/2 + x}px`;
                number.style.top = `${window.innerHeight/2 + y}px`;
                container.appendChild(number);
                
                setTimeout(() => {
                    number.classList.add('active');
                }, i * staggerDelay);
                
                setTimeout(() => {
                    number.classList.remove('active');
                    setTimeout(() => number.remove(), 1000);
                }, duration + i * staggerDelay);
            }
        }

        function createConnections() {
            const total = 30;
            const duration = 4000;
            const staggerDelay = duration / total;

            for (let i = 0; i < total; i++) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                // Create more interesting patterns with sine waves
                const angle = (i / total) * Math.PI * 2;
                const radius = Math.min(window.innerWidth, window.innerHeight) * 0.3;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                line.style.width = '0';
                line.style.left = `${window.innerWidth/2 + x}px`;
                line.style.top = `${window.innerHeight/2 + y}px`;
                line.style.transform = `rotate(${angle * (180/Math.PI)}deg)`;
                container.appendChild(line);
                
                setTimeout(() => {
                    line.style.opacity = '0.7';
                    line.style.width = `${radius}px`;
                }, i * staggerDelay);
                
                setTimeout(() => {
                    line.style.opacity = '0';
                    setTimeout(() => line.remove(), 1000);
                }, duration + i * staggerDelay);
            }
        }

        function createHearts() {
            const total = 15;
            const duration = 4000;
            const staggerDelay = duration / total;

            for (let i = 0; i < total; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                
                // Create spiral pattern
                const angle = (i / total) * Math.PI * 6;
                const radius = (i / total) * Math.min(window.innerWidth, window.innerHeight) * 0.3;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                heart.style.left = `${window.innerWidth/2 + x}px`;
                heart.style.top = `${window.innerHeight/2 + y}px`;
                container.appendChild(heart);
                
                setTimeout(() => {
                    heart.classList.add('active');
                }, i * staggerDelay);
                
                setTimeout(() => {
                    heart.classList.remove('active');
                    setTimeout(() => heart.remove(), 1000);
                }, duration + i * staggerDelay);
            }
        }

        function startBassAnimation() {
            const initialShape = document.createElement('div');
            initialShape.className = 'shape fade-transition';
            container.appendChild(initialShape);
            
            setTimeout(() => {
                initialShape.style.opacity = '1';
                playTheremin(220, 2.0);
                
                setTimeout(() => {
                    initialShape.style.opacity = '0';
                    
                    // Create spiraling pattern of spirals
                    const totalSpirals = 8;
                    for (let i = 0; i < totalSpirals; i++) {
                        const spiral = document.createElement('div');
                        spiral.className = 'spiral fade-transition';
                        container.appendChild(spiral);
                        
                        const angle = (i / totalSpirals) * Math.PI * 2;
                        const radius = Math.min(window.innerWidth, window.innerHeight) * 0.3;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        spiral.style.left = `${window.innerWidth/2 + x}px`;
                        spiral.style.top = `${window.innerHeight/2 + y}px`;
                        
                        setTimeout(() => {
                            spiral.style.opacity = '1';
                            spiral.style.transform = `translate(-50%, -50%) scale(${i/2 + 1}) rotate(${i * 45}deg)`;
                            playTheremin(440 + i * 110, 0.5);
                        }, i * 300);
                        
                        setTimeout(() => {
                            spiral.style.opacity = '0';
                            spiral.style.transform += ' scale(2)';
                            setTimeout(() => spiral.remove(), 1000);
                        }, 2000 + i * 300);
                    }
                    
                    // Create watching eye with smooth entrance
                    setTimeout(() => {
                        const eye = document.createElement('div');
                        eye.className = 'watching-eye fade-transition';
                        const pupil = document.createElement('div');
                        pupil.className = 'pupil fade-transition';
                        eye.appendChild(pupil);
                        container.appendChild(eye);
                        
                        // Position in center
                        eye.style.left = '50%';
                        eye.style.top = '50%';
                        eye.style.transform = 'translate(-50%, -50%) scale(0.5)';
                        
                        setTimeout(() => {
                            eye.style.opacity = '1';
                            eye.style.transform = 'translate(-50%, -50%) scale(1)';
                            
                            // Organic pupil movement
                            const pupilInterval = setInterval(() => {
                                const angle = Math.random() * Math.PI * 2;
                                const radius = Math.random() * 20;
                                const x = Math.cos(angle) * radius;
                                const y = Math.sin(angle) * radius;
                                pupil.style.transform = `translate(${x}px, ${y}px)`;
                            }, 1000);
                            
                            setTimeout(() => {
                                eye.style.opacity = '0';
                                eye.style.transform = 'translate(-50%, -50%) scale(1.5)';
                                clearInterval(pupilInterval);
                                setTimeout(() => eye.remove(), 1000);
                            }, 3000);
                        }, 100);
                    }, 3000);
                    
                    // Enhanced theremin sequence
                    const frequencies = [440, 880, 220, 660, 330];
                    frequencies.forEach((freq, i) => {
                        setTimeout(() => playTheremin(freq, 1.0), i * 500);
                    });

                    setTimeout(() => initialShape.remove(), 1000);
                }, 3000);
            }, 50);
        }

        function initMemoryPool() {
            const totalFragments = 641;
            const dotsPerFragment = 2;
            const poolDots = 100;

            // Create memory fragments with dots
            for (let i = 0; i < totalFragments; i++) {
                const fragment = document.createElement('div');
                fragment.className = 'memory-fragment';
                
                // Add frosted dots to each fragment
                for (let j = 0; j < dotsPerFragment; j++) {
                    const dot = document.createElement('div');
                    dot.className = 'frosted-dot';
                    dot.style.left = `${Math.random() * 80 + 10}%`;
                    dot.style.top = `${Math.random() * 80 + 10}%`;
                    dot.style.animationDelay = `${Math.random() * 2}s`;
                    fragment.appendChild(dot);
                }
                
                memoryPool.appendChild(fragment);
                
                // Stagger the appearance
                fragment.style.opacity = '0';
                fragment.style.transform = 'scale(0.8)';
                setTimeout(() => {
                    fragment.style.opacity = '1';
                    fragment.style.transform = 'scale(0.9)';
                }, i * 10);
            }
            
            // Add ambient frosted dots to the pool
            for (let i = 0; i < poolDots; i++) {
                const poolDot = document.createElement('div');
                poolDot.className = 'pool-dot';
                poolDot.style.left = `${Math.random() * 100}%`;
                poolDot.style.top = `${Math.random() * 100}%`;
                poolDot.style.animationDelay = `${Math.random() * 3}s`;
                poolDot.style.animationDuration = `${4 + Math.random() * 2}s`;
                memoryPool.appendChild(poolDot);
            }
        }

        function initHypercube() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a0a0a, 0);

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            // Create vertices from 2D element positions
            document.querySelectorAll('.number, .heart, .face, .spiral').forEach(element => {
                const rect = element.getBoundingClientRect();
                const x = (rect.left / window.innerWidth) * 20 - 10;
                const y = -(rect.top / window.innerHeight) * 20 + 10;
                const z = Math.random() * 5 - 2.5; // Reduced z-depth range

                vertices.push(x, y, z);
                colors.push(
                    0.95 + Math.random() * 0.05, // More consistent pink
                    0.3 + Math.random() * 0.1,
                    0.7 + Math.random() * 0.1
                );
            });

            // Add remaining particles in a more organized pattern
            const remainingCount = 641 - (vertices.length / 3);
            const gridSize = Math.ceil(Math.sqrt(remainingCount));
            
            for (let i = 0; i < remainingCount; i++) {
                const gridX = (i % gridSize) / gridSize - 0.5;
                const gridY = Math.floor(i / gridSize) / gridSize - 0.5;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.2; // Small random offset
                
                vertices.push(
                    gridX * 20 + Math.cos(angle) * radius,
                    gridY * 20 + Math.sin(angle) * radius,
                    Math.random() * 3 - 1.5 // Reduced z-depth for final layer
                );
                colors.push(
                    0.95 + Math.random() * 0.05, // More consistent pink
                    0.3 + Math.random() * 0.1,
                    0.7 + Math.random() * 0.1
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2.5, // Slightly larger points
                vertexColors: true,
                transparent: true,
                opacity: 0,
                sizeAttenuation: true // Enable size attenuation
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            camera.position.z = 25;

            let opacity = 0;
            const targetOpacity = 0.8;

            function animate() {
                requestAnimationFrame(animate);
                
                if (opacity < targetOpacity) {
                    opacity += 0.01;
                    material.opacity = opacity;
                }
                
                points.rotation.x += 0.001;
                points.rotation.y += 0.002;
                
                if(Math.random() < 0.02) {
                    points.rotation.z += (Math.random() - 0.5) * 0.1;
                }
                
                renderer.render(scene, camera);
            }

            animate();
            return { points, material };
        }

        function glitch() {
            title.classList.add('glitch');
            setTimeout(() => title.classList.remove('glitch'), 1000);
        }

        // Saul Bass inspired intro sequence
        function playIntroSequence() {
            const introContainer = document.querySelector('.intro-container');
            const introBar = document.querySelector('.intro-bar');
            const introCircle = document.querySelector('.intro-circle');
            const introText = document.querySelector('.intro-text');
            const introNumber = document.querySelector('.intro-number');
            
            // Initial dramatic sound
            playNote(220, 2.0);
            
            // Animate intro bar
            setTimeout(() => {
                introBar.style.width = '80vw';
                playNote(440, 0.5);
            }, 500);
            
            // Animate circle
            setTimeout(() => {
                introCircle.style.transform = 'scale(1)';
                introCircle.style.opacity = '1';
                playNote(330, 1.0);
            }, 1500);
            
            // Animate text
            setTimeout(() => {
                introText.style.opacity = '1';
                introText.style.transform = 'scale(1)';
                playNote(550, 0.3);
            }, 2500);
            
            // Animate number
            setTimeout(() => {
                introNumber.style.opacity = '1';
                introNumber.style.transform = 'scale(1)';
                playNote(660, 0.8);
            }, 3000);
            
            // Slide out intro
            setTimeout(() => {
                introContainer.classList.add('slide-out');
                playNote(880, 1.5);
                startMainSequence();
            }, 4500);
        }

        // Enhanced main sequence
        function startMainSequence() {
            const dramaticOverlay = document.querySelector('.dramatic-overlay');
            const dramaticLine = document.querySelector('.dramatic-line');
            const dramaticText = document.querySelector('.dramatic-text');
            
            // Phase 1: Dramatic entrance (0-8s)
            setTimeout(() => {
                dramaticOverlay.style.opacity = '1';
                dramaticLine.style.width = '60vw';
                dramaticLine.style.opacity = '1';
                dramaticText.style.opacity = '1';
                dramaticText.style.transform = 'translateY(0)';
            }, 1000);
            
            // Phase 2: Rothko sequence (6-14s)
            setTimeout(() => {
                dramaticText.style.opacity = '0';
                dramaticLine.style.opacity = '0';
                document.body.style.backgroundColor = '#1a0033';
                createRothkoWindows();
            }, 6000);
            
            // Phase 3: Face grid emergence (12-20s)
            setTimeout(() => {
                document.body.style.backgroundColor = '#330033';
                createFaceGrid();
            }, 12000);
            
            // Phase 4: Numeric sequence (18-26s)
            setTimeout(() => {
                document.body.style.backgroundColor = '#220011';
                createNumberGrid();
                setTimeout(createConnections, 2000);
                setTimeout(createHearts, 4000);
            }, 18000);
            
            // Phase 5: Bass animation (24-32s)
            setTimeout(() => {
                document.body.style.backgroundColor = '#110022';
                startBassAnimation();
            }, 24000);
            
            // Phase 6: Memory emergence (30-36s)
            setTimeout(() => {
                document.body.style.backgroundColor = '#000033';
                title.classList.add('active');
                glitch();
                
                memoryPool.classList.add('active');
                const fragments = document.querySelectorAll('.memory-fragment');
                fragments.forEach((fragment, i) => {
                    setTimeout(() => {
                        fragment.style.opacity = '1';
                        fragment.style.transform = 'scale(1)';
                    }, i * 30);
                });
            }, 30000);
            
            // Phase 7: Hypercube transformation (34s+)
            setTimeout(() => {
                document.body.style.backgroundColor = '#000000';
                dramaticOverlay.style.opacity = '0';
                
                canvas.style.opacity = '1';
                const { points, material } = initHypercube();
                
                // Dramatic point transformation
                const positions = points.geometry.attributes.position;
                const originalPositions = positions.array.slice();
                
                function animateToHypercube(progress) {
                    const easedProgress = Math.pow(progress, 3); // Cubic easing
                    for (let i = 0; i < positions.array.length; i += 3) {
                        positions.array[i] = originalPositions[i] * (1 - easedProgress) + 
                            (Math.random() - 0.5) * 20 * easedProgress;
                        positions.array[i + 1] = originalPositions[i + 1] * (1 - easedProgress) + 
                            (Math.random() - 0.5) * 20 * easedProgress;
                        positions.array[i + 2] = originalPositions[i + 2] * (1 - easedProgress) + 
                            (Math.random() - 0.5) * 20 * easedProgress;
                    }
                    positions.needsUpdate = true;
                }
                
                const startTime = Date.now();
                const duration = 4000; // 4 seconds for more dramatic effect
                
                function updatePoints() {
                    const progress = Math.min((Date.now() - startTime) / duration, 1);
                    animateToHypercube(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(updatePoints);
                    }
                }
                
                updatePoints();
            }, 34000);
            
            // Dramatic audio accompaniment
            const harmonics = [1, 1.5, 2, 2.5, 3, 4, 6];
            for (let i = 0; i < 40; i++) {
                setTimeout(() => {
                    const baseFreq = 220;
                    const harmonic = harmonics[Math.floor(Math.random() * harmonics.length)];
                    playNote(baseFreq * harmonic, 1.0);
                }, 8000 + (i * 800));
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.updateProjectionMatrix();
            const renderer = new THREE.WebGLRenderer({ canvas });
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function startFinalTransition() {
            const finalLayer = document.querySelector('.final-layer');
            finalLayer.classList.add('active');
            
            // Create final chord
            const baseFreq = 220; // A3
            const harmonics = [1, 1.5, 2, 2.5, 3];
            const oscillators = [];
            
            harmonics.forEach(harmonic => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0;
                
                osc.frequency.value = baseFreq * harmonic;
                osc.type = 'sine';
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start();
                gain.gain.setTargetAtTime(0.15 / harmonics.length, audioContext.currentTime, 1);
                
                oscillators.push({ osc, gain });
            });
            
            // Fade out existing sounds
            if (audioSystem.currentDrone) {
                audioSystem.currentDrone.oscillators.forEach(osc => {
                    osc.gain.gain.setTargetAtTime(0, audioContext.currentTime, 0.5);
                });
            }
            
            // Final fade out
            setTimeout(() => {
                oscillators.forEach(({ gain }) => {
                    gain.gain.setTargetAtTime(0, audioContext.currentTime, 2);
                });
            }, 6000);
        }

        setTimeout(startFinalTransition, 40000);
    </script>
    <div class="final-layer"></div>
<!-- Code injected by live-server -->
<script>
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script>
</body>
</html>
